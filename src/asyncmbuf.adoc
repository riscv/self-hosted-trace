== Asynchronous Memory Buffer ISA Extension (Ssamb)

An asynchronous memory buffer (AMB) serves as a sink for trace, or similar asynchronous data, generated by hardware in parallel with software execution.  Multiple such buffers may be implemented by a hart, depending on the number of separate sources of asynchronous data generation implemented.

The buffer is contiguous in the virtual address space, but may be distributed in the physical (or guest physical) address space.  It is a circular buffer, such that writes commence at the base, and overwrite any older data there, once the buffer is full.  There exists a mechanism to pend a local interrupt before the buffer wraps, for cases where software does not wish to have any asynchronous data overwritten.

Ssamb is never implemented as a stand-alone extension, each instance of Ssamb is implemented alongside one or more sources of asynchronous data associated with it.  For each instance of Ssamb the `samb*` registers below will be implemented, with names and CSR numbers specific to the feature or extension that employs Ssamb.

WARNING: _There is still an open question whether AMB should simply require pinned pages, and throw an error if a translation fault occurs.  Other architectures have such requirements.  Pinning requires that the entire buffer be kept resident, which adds to memory pressure, and limits the size of the buffer. But it avoids some hardware complexity and page fault overheads._

=== CSRs

==== Supervisor Asynchronous Memory Buffer Configuration and Status Register (`sambcs`)

The `sambcs` register is a 64-bit WARL register that provides configuration and status fields for the Asynchronous Memory Buffer.  

.Supervisor Asynchronous Memory Buffer Configuration and Status Register (`sambcs`)
[wavedrom, , svg]
....
{reg: [
    {bits: 5, name: 'SIZE'},
    {bits: 4, name: 'WARL', type: 1},
    {bits: 2, name: 'BMITH'},
    {bits: 1, name: 'BMIEN'},
    {bits: 20, name: 'TFPTR'},
    {bits: 27, name: 'WARL', type: 1},
    {bits: 1, name: 'TF'},
    {bits: 1, name: 'BMI'},
    {bits: 1, name: 'WRAP'},
    {bits: 1, name: 'EMPTY'},
    {bits: 1, name: 'TRV'},
], config:{lanes: 4, hspace:1024}}
....

The buffer size is 2^SIZE+12^, supporting sizes from 4 KB (SIZE=0) to 4 GB (SIZE=20).  SIZE values 21..31 are reserved.  An AMB instance may support only a subset of SIZE values.  The maximum supported size can be discovered by writing all 1s to SIZE and reading back the resulting value.  All sizes between the minimum (4 KB) and the maximum supported size are supported.

WARNING: _The largest AUX buffer size allowed by Linux perf for self-hosted trace from other architectures is 4 MiB, but those require pinned memory._

The BMIEN bit enables buffer management interrupts.  When BMIEN=1, a local asynchronous memory buffer interrupt (LAMBI) is pended when hardware increment of `sambaddr` causes the two most significant bits of the the write pointer offset portion to transition to match BMITH.  For example, if BMIEN=1 and BMITH=2, a LAMBI will be pended when the buffer is half full.

WARNING: _would software ever just use AMB translation faults to track buffer progress, avoiding the need for BMIs?_

The TF and BMI bits report the source of a pended LAMBI.  When BMI=1, a buffer management interrupt was pended.  When TF=1, a buffer translation fault occurred. See <<ambaddr>> for address translation details.

NOTE: _Unlike explicit stores, asynchronous memory buffer writes do not raise "Store/AMO Page Fault" exceptions as a result of translation faults.  By instead pending a LAMBI with TF=1, an AMB translation fault can remain pending if it cannot be handled in the current privilege mode._

When a buffer translation fault occurs, the buffer offset associated with the offending page is written to TFPTR, such that the full virtual address of the page base can be derived by combining the base address portion of `sambaddr` with the offset value as shown below.

FaultAddress = (`sambaddr` & (2^`sambcs`.SIZE+12^ - 1)) | (`sambcs`.TFPTR<<12)

NOTE: _Because implementations may pre-translate AMB pages (see <<ambaddr>>), the address in `sambaddr` may not reflect the page that incurred the AMB translation fault.  The TFPTR provides a means to report a fault to a different page._

NOTE: _When an AMB page lookup raises a translation fault, the lookup may be suspended.  If trace is then disabled, the lookup should be resumed when trace is re-enabled.  Otherwise the lookup should resume once the TF bit is cleared by software, indicating that the page is now available._

WARNING: _Extensions that use AMB probably want to include a bit that inhibits asynchronous data generation during LAMBI handling.  Inhibit for any interrupt to mode __x__ when __x__cause.LAMBI=1?_

The EMPTY bit is a read-only indication to software that all internally buffered asynchronous data has been flushed and should be visible to software reads.  Disabling the asynchronous data source effects a flush of any internally buffered data, such that EMPTY=1 follows  thereafter.

The WRAP bit indicates that the buffer has wrapped at least once, and hence the data above the write pointer is valid.

The TRV bit is a read-only indication to software that the hardware has successfully translated the buffer current page, and optionally one or more following pages.  

NOTE: _Software may opt to poll on this bit after enabling the asynchronous data source, in order to minimize the risk of asynchronous data associated with the workload being dropped while awaiting resolution of the translation(s)._

It is strongly recommended that software only write to `sambcs` while any associated asynchronous data sources are disabled.  This avoids race conditions between software writes and hardware updates of status fields.

==== Supervisor Asynchronous Memory Buffer Address Register (`sambaddr`)

The `sambaddr` register is an SXLEN-wide WARL register that holds the virtual address to which the next byte of asynchronous data will be written.  Upon each hardware write to the AMB, the address is incremented by the number of bytes written.

The address actually comprises the buffer base and the write pointer offset.  Because the buffer base is aligned to its size, the write pointer offset is `sambaddr`[(11 + `sambcs`.SIZE):0].  When hardware writes the last byte of the buffer, the write pointer offset portion wraps to 0.

Some instantiations of AMB may support only buffer writes that are aligned to a fixed size.  In such cases the least significant bits of `sambaddr`, those that offset into the aligned range, may be hardcoded to 0.

`sambaddr` need not be capable of holding an invalid address.

==== Interrupt Registers

WARNING: _This section gets integrated into 3.1.9 and others_

The local asynchronous memory buffer interrupt (LAMBI) bit in `mip`, `mie`, and `mideleg` is writable.  For implementations that support S-mode, the LAMBI bit in `sip` and `sie` is writable.  For implementations that support the H extension, the LAMBI bit in `vsip` and `vsie` is writable, and, when `mideleg`.LAMBI=1, the LAMBI bit in `hideleg` is writable.

For implementations that support Smaia, the LAMBI bit in `mvip` and `mvien` is writable.  For implementations that support Smaia/Ssaia and the H extension, the LAMBI bit in `hvip` and `hvien` is writable.

The priority of LAMBIs lies immediately below that of local counter overflow interrupts (LCOFIs).

=== AMB Memory Semantics

Like other stores, the ordering and cache semantics of hardware AMB writes are dictated by PMAs and/or page-based memory types (Svpbmt).  However, hardware writes of asynchronous data are not ordered with respect to explicit memory operations, including fences.  To effect an asynchronous data fence software should disable the asynchronous data source, and wait for `sambcs`.EMPTY=1.

[NOTE]
====
_For asynchronous data sources that are processed offline (e.g., instruction trace), it is likely desirable to assign buffer pages a non-cacheable but weakly ordered attribute (e.g., PBMT=NC).  This avoids having trace data that won't be read soon displace workload working set data from the caches._

_For asynchronous data sources that are processed online (e.g., sample records, such that each record is collected as it is written), it may be desirable to assign buffer pages a cacheable attribute.  This avoids adding cache-miss latency to online collection routines._
====

Any dropping of asynchronous data must happen at the source, to ensure that the data loss is recoverable.  An AMB implementation must apply backpressure to the source to avoid scenarios where asynchronous data may be dropped downstream from the source.

[NOTE]
====
_To avoid scenarios where the source is flushed but the AMB is not able to sink all asynchrnonous data bytes, the implementation should backpressure the source before the remaining translated AMB space is less than the size of the internal buffer.  Otherwise there is a risk that a translation fault is needed to in order to sink buffered data, and the LAMBI trap could lead to the source being disabled (e.g., due to context switch) before the fault is handled.  This would result in unrecoverable data loss._
====

[[ambaddr]]
=== AMB Privilege and Address Translation

The effective privilege mode of AMB writes is selected by bits associated with each AMB instance in `menvcfg` and, if the H extension is implemented, `henvcfg`.  For the AMB associated with self-hosted trace (STRC), the full set of configuration options is illustrated below.

[options="header", width="70%"]
|===
| `menvcfg`.STRCS | `henvcfg`.STRCV | Privilege | Translation
| 0 | - | M-mode | None (Bare)
| 1 | 0 | S/HS-mode | `satp`
| 1 | 1 | VS-mode | `vsatp`/`hgatp`
|===

[NOTE]
====
_Using a fixed effective privilege mode for asynchronous data writes, rather than using the current privilege mode, allows supporting system-wide uses, where recording persists across privilege modes._

_This mechanism is also motivated by an expectation that implementations may buffer asynchronous data internally before it is emitted to the AMB, in order to avoid data loss during asynchronous data bursts.  This translation approach avoids the need to delay traps and trap returns by requiring internal buffers to be flushed before the current privilege mode changes.  Asynchronous data can continue to be emitted with the same privilege and translation despite changes to the current privilege mode._
====

The process of translating AMB write addresses can result in translation faults.  A page fault incurred during first-level page lookup, based on `satp` when the effective privilege mode is S-mode or `vsatp` when the effective privilege mode is VS-mode, raises a LAMBI interrupt with a cause of translation fault (`sambcs`.TF=1), and the buffer offset of the offending page indicated in `sambcs`.TFPTR.

A page fault incurred during the second-level, or G-stage, page lookup raises a Store/AMO guest-page fault, just as explicit and other implicit stores do.  When AMB writes execute with VS-mode privilege, and Store/AMO guest-page faults are delegated to S-mode (mideleg[23]=1), AMB page lookups must be suspended while in M-mode.  This avoids Store/AMO guest-page faults raised in M-mode, where they cannot be handled.

NOTE: _If the asynchronous data source is backpressured while waiting for the current AMB page to be translated, there is a risk of data loss due to internal buffer overflow.  One method to avoid such loss is to pre-translate the next AMB page(s), ensuring that the translation(s) are cached before the page(s) need to be written.  A simple implementation would cache translations for the current and next AMB page.  When page X is filled, writes transition to (already translated) page X+1, and translation begins for page X+2.  It is recommended that the number of pages pre-translated is sufficient to match or exceed the size of any internal buffering, to ensure that the internal buffer can always be flushed without requiring a page walk or translation fault._

Cached AMB page translations can be flushed by SFENCE and HFENCE instructions, globally or per ASID/VMID, just as other translations are.  Cached AMB page translations are also flushed when the asynchronous data source is disabled.

NOTE: _Depending on the AMB buffer size and data rate, AMB writes can touch many pages in a short amount of time.  However, AMB uses page translations efficiently, writing exclusively to a single page until it is full, then moving to the next and writing exclusively to it.  Rather than allowing AMB writes to displace explicit memory access translations from the primary TLB, it may be more efficient to store cached AMB translations in a very small dedicated AMB TLB.  Two entries (current page and next page) are probably sufficient for most implementations, though more may be warranted if the implementation pre-translates more than one page ahead._

WARNING: _should AMB have its own enable bit?  such that translations are fetched when it's enabled, and flushed when it's disabled, regardless of data source enabling?  Then SW could enable the buffer, and only enable the source once TRV=1..._
